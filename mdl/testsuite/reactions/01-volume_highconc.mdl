/****************************************************************************
 * Test 01: All volume rxn types, simple test of equilibrium and reaction
 *          rates.
 *
 *    A quantitative test of the basic volume-volume reaction types (uni, bi,
 *    tri).  Note that this does NOT test TARGET_ONLY reactions or reactions
 *    with no products (or more than 3 products).
 *
 * Author: Jed Wing <jed@salk.edu>
 * Date:   2008-11-07
 ****************************************************************************/

basename = "01-volume_highconc"
countdir = "dat/" & basename & "/"
vizdir   = "./viz_dat/" & basename & "/"

iterations = 10000
timestep = 1e-6
boxdims = 0.25
voldiffconst = 2.0e-6

num_u = 1000
num_b = 1000
num_t = 1000

// Set reverse rates to expect approx 1 rxn every 10 timesteps
rr_u = 2.0e2
rr_b = 2.0e2
rr_t = 2.0e2

// Compute forward rates to give equilibrium of 50% reacted
boxvol = 8*boxdims*boxdims*boxdims
c_b = (num_b / 2. / boxvol) * 1e15 / 6.022e23
c_t = (num_t / 2. / boxvol) * 1e15 / 6.022e23
rf_u = rr_u
rf_b = rr_b / c_b
rf_t = rr_t / c_t / c_t

/* ACCURATE_3D_REACTIONS = FALSE */

PARTITION_X = [ [ -0.3 TO 0.3 STEP 0.025 ] ]
PARTITION_Y = [ [ -0.3 TO 0.3 STEP 0.025 ] ]
PARTITION_Z = [ [ -0.3 TO 0.3 STEP 0.025 ] ]

ITERATIONS = iterations
TIME_STEP = timestep
TIME_STEP_MAX = 1.0

INCLUDE_FILE = "volmols.mdl"

DEFINE_REACTIONS {
  V_u  -> I_u                 [rf_u] : fwd_u
  V_b1 + V_b2  -> I_b         [rf_b] : fwd_b
  V_t1 + V_t2 + V_t3  -> I_t  [rf_t] : fwd_t
  I_u  -> V_u                 [rr_u] : rev_u
  I_b  -> V_b1 + V_b2         [rr_b] : rev_b
  I_t  -> V_t1 + V_t2 + V_t3  [rr_t] : rev_t
}

main_box BOX
{
    CORNERS = [-boxdims, -boxdims, -boxdims], [boxdims, boxdims, boxdims]
}

INSTANTIATE world OBJECT
{
    main_box OBJECT main_box {}
    release_site_1r RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = V_u
        NUMBER_TO_RELEASE = num_u / 2
    }
    release_site_1p RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = I_u
        NUMBER_TO_RELEASE = num_u / 2
    }

    release_site_2r1 RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = V_b1
        NUMBER_TO_RELEASE = num_b / 2
    }
    release_site_2r2 RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = V_b2
        NUMBER_TO_RELEASE = num_b / 2
    }
    release_site_2p RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = I_b
        NUMBER_TO_RELEASE = num_b / 2
    }

    release_site_3r1 RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = V_t1
        NUMBER_TO_RELEASE = num_t / 2
    }
    release_site_3r2 RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = V_t2
        NUMBER_TO_RELEASE = num_t / 2
    }
    release_site_3r3 RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = V_t3
        NUMBER_TO_RELEASE = num_t / 2
    }
    release_site_3p RELEASE_SITE {
        SHAPE = world.main_box
        MOLECULE = I_t
        NUMBER_TO_RELEASE = num_t / 2
    }
}

REACTION_DATA_OUTPUT {
  OUTPUT_BUFFER_SIZE = 50
  STEP = timestep*10
  HEADER = "# "
  {
    COUNT[V_u,world.main_box]  : "V_u",
    COUNT[V_b1,world.main_box] : "V_b1",
    COUNT[V_b2,world.main_box] : "V_b2",
    COUNT[V_t1,world.main_box] : "V_t1",
    COUNT[V_t2,world.main_box] : "V_t2",
    COUNT[V_t3,world.main_box] : "V_t3",
    COUNT[I_u,world.main_box]  : "I_u",
    COUNT[I_b,world.main_box]  : "I_b",
    COUNT[I_t,world.main_box]  : "I_t"
  }     => countdir & "V_out.dat"
  {
    COUNT[fwd_u,WORLD]         : "fwd_u",
    COUNT[fwd_b,WORLD]         : "fwd_b",
    COUNT[fwd_t,WORLD]         : "fwd_t",
    COUNT[rev_u,WORLD]         : "rev_u",
    COUNT[rev_b,WORLD]         : "rev_b",
    COUNT[rev_t,WORLD]         : "rev_t"
  }     => countdir & "rxn_out.dat"
}
